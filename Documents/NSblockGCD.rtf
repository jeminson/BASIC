{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf760
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fnil\fcharset0 LucidaGrande;\f2\fnil\fcharset0 Menlo-Regular;
\f3\froman\fcharset0 Times-Roman;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 LucidaGrande-Bold;
\f6\fnil\fcharset0 Monaco;\f7\fswiss\fcharset0 ArialMT;\f8\fnil\fcharset0 Consolas;
\f9\fswiss\fcharset0 Helvetica;\f10\fnil\fcharset0 HelveticaNeue;\f11\fnil\fcharset0 Consolas-Bold;
}
{\colortbl;\red255\green255\blue255;\red37\green37\blue37;\red255\green255\blue255;\red0\green0\blue0;
\red15\green15\blue16;\red234\green234\blue234;\red83\green85\blue2;\red0\green0\blue117;\red106\green0\blue67;
\red16\green121\blue2;\red60\green76\blue108;\red102\green102\blue102;\red241\green245\blue249;\red199\green207\blue213;
\red191\green191\blue191;\red112\green130\blue132;\red33\green118\blue199;\red37\green146\blue134;\red173\green118\blue5;
\red106\green145\blue4;\red29\green29\blue29;\red11\green87\blue42;\red19\green20\blue21;\red20\green20\blue21;
\red26\green26\blue26;\red11\green96\blue192;\red100\green100\blue100;\red26\green27\blue29;}
{\*\expandedcolortbl;;\cssrgb\c19216\c19216\c19216;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c7059\c7059\c7843;\cssrgb\c93333\c93333\c93333;\cssrgb\c40000\c40000\c0;\cssrgb\c0\c0\c53333;\cssrgb\c49804\c0\c33333;
\cssrgb\c0\c53333\c0;\csgenericrgb\c23529\c29804\c42353;\csgenericrgb\c40000\c40000\c40000;\csgenericrgb\c94510\c96078\c97647;\csgenericrgb\c78039\c81176\c83529;
\csgray\c79525;\csgenericrgb\c43922\c50980\c51765;\csgenericrgb\c12941\c46275\c78039;\csgenericrgb\c14510\c57255\c52549;\csgenericrgb\c67843\c46275\c1961;
\csgenericrgb\c41569\c56863\c1569;\csgenericrgb\c11373\c11373\c11373;\csgenericrgb\c4314\c34118\c16471;\csgenericrgb\c7451\c7843\c8235;\csgenericrgb\c7843\c7843\c8235;
\csgenericrgb\c10196\c10196\c10196;\csgenericrgb\c4314\c37647\c75294;\csgenericrgb\c39216\c39216\c39216;\csgenericrgb\c10196\c10588\c11373;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\margl1440\margr1440\vieww13080\viewh12500\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs30 \cf2 \cb3 \expnd0\expndtw0\kerning0
\

\b BLOCK\
\
\pard\pardeftab720\partightenfactor0

\b0\fs28 \cf0 \cb3 Blocks are one of the most fundamentally useful iOS technologies. You pass blocks to methods and functions as arguments so that they can be stored and executed at later times. Blocks enable you to move those implementation details away from isolated callbacks and into the actual context where they're most meaningful. This approach improves readability and inspection because the way items react before, during, and after some process are most relevant at the point where that process is defined.\cf2 \cb3 \
An Objective-C class defines an object that combines data with related behavior. Sometimes, it makes sense just to represent a single task or unit of behavior, rather than a collection of methods.\
Blocks are a language-level feature added to C, Objective-C and C++ which allow you to create distinct segments of code that can be passed around to methods or functions as if they were values. Blocks are Objective-C objects which means they can be added to collections like NSArray or NSDictionary. They also have the ability to capture values from the enclosing scope, making them similar to closures or lambdas in other programming languages
\fs30 \
\pard\pardeftab720\ri720\sa200\partightenfactor0

\f1\fs20 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0\fs47\fsmilli23800 \cf5 \cb3 \expnd0\expndtw0\kerning0
\shad\shadx20\shady-20\shadr40\shado255 \shadc0 Simple Block declaration syntax\cb1 \

\f2\fs26 \cf2 \cb6 \shad0 returntype \cf7 (^\cf2 blockName\cf7 )(\cf2 argumentType\cf7 );\cf2 \
\pard\pardeftab720\partightenfactor0

\f0\fs30 \cf2 \cb3 Simple block implementation\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf2 \cb6 returntype \cf7 (^\cf2 blockName\cf7 )(\cf2 argumentType\cf7 )=\cf2  \cf7 ^\{\cf2 \
\cf7 \};\cf2 \

\f0\fs47\fsmilli23800 \cf5 \cb3 \shad\shadx20\shady-20\shadr40\shado255 \shadc0 Here is a simple example\cb1 \

\f2\fs26 \cf8 \cb6 \shad0 void\cf2  \cf7 (^\cf2 simpleBlock\cf7 )(\cf8 void\cf7 )\cf2  \cf7 =\cf2  \cf7 ^\{\cf2 \
    \cf9 NSLog\cf7 (@\cf10 "This is a block"\cf7 );\cf2 \
\cf7 \};\cf2 \

\f0\fs47\fsmilli23800 \cf5 \cb3 \shad\shadx20\shady-20\shadr40\shado255 \shadc0 We can invoke the block using\cb1 \

\f2\fs26 \cf2 \cb6 \shad0 simpleBlock\cf7 ();
\f1\fs20 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\ri720\sb420\sa100\partightenfactor0

\f3\fs36 \cf11 Block Syntax\
\pard\pardeftab720\ri720\sa200\partightenfactor0

\f1\fs20 \cf0 The syntax to define a block literal uses the caret symbol (
\f4 \cf12 ^
\f1 \cf0 ), like this:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrt\brdrs\brdrw15\brdrcf14 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw15\brdrcf14 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw20\brdrcf15 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0

\f4\fs18 \cf12     ^\{\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw20\brdrcf15 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw20\brdrcf15 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0
\cf12          NSLog(@"This is a block");\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrb\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw20\brdrcf15 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw15\brdrcf14 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0
\cf12     \}\cell \lastrow\row
\pard\pardeftab720\ri720\sa200\partightenfactor0

\f1\fs20 \cf0 As with function and method definitions, the braces indicate the start and end of the block. In this example, the block doesn\'92t return any value, and doesn\'92t take any arguments.\
In the same way that you can use a function pointer to refer to a C function, you can declare a variable to keep track of a block, like this:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrt\brdrs\brdrw15\brdrcf14 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrb\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw15\brdrcf14 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw15\brdrcf14 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0

\f4\fs18 \cf12     void (^simpleBlock)(void);\cell \lastrow\row
\pard\pardeftab720\ri720\sa200\partightenfactor0

\f1\fs20 \cf0 If you\'92re not used to dealing with C function pointers, the syntax may seem a little unusual. This example declares a variable called\'a0
\f4 \cf12 simpleBlock
\f1 \cf0 \'a0to refer to a block that takes no arguments and doesn\'92t return a value, which means the variable can be assigned the block literal shown above, like this:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrt\brdrs\brdrw15\brdrcf14 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw15\brdrcf14 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw20\brdrcf15 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0

\f4\fs18 \cf12     simpleBlock = ^\{\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw20\brdrcf15 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw20\brdrcf15 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0
\cf12         NSLog(@"This is a block");\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrb\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw20\brdrcf15 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw15\brdrcf14 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0
\cf12     \};\cell \lastrow\row
\pard\pardeftab720\ri720\sa200\partightenfactor0

\f1\fs20 \cf0 This is just like any other variable assignment, so the statement must be terminated by a semi-colon after the closing brace. You can also combine the variable declaration and assignment:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrt\brdrs\brdrw15\brdrcf14 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw15\brdrcf14 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw20\brdrcf15 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0

\f4\fs18 \cf12     void (^simpleBlock)(void) = ^\{\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw20\brdrcf15 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw20\brdrcf15 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0
\cf12         NSLog(@"This is a block");\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrb\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw20\brdrcf15 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw15\brdrcf14 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0
\cf12     \};\cell \lastrow\row
\pard\pardeftab720\ri720\sa200\partightenfactor0

\f1\fs20 \cf0 Once you\'92ve declared and assigned a block variable, you can use it to invoke the block:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth15120\trftsWidth3 \trbrdrt\brdrs\brdrw15\brdrcf14 \trbrdrl\brdrs\brdrw15\brdrcf14 \trbrdrb\brdrs\brdrw15\brdrcf14 \trbrdrr\brdrs\brdrw15\brdrcf14 
\clvertalc \clcbpat13 \clbrdrt\brdrs\brdrw15\brdrcf14 \clbrdrl\brdrs\brdrw15\brdrcf14 \clbrdrb\brdrs\brdrw15\brdrcf14 \clbrdrr\brdrs\brdrw15\brdrcf14 \clpadt120 \clpadl120 \clpadb120 \clpadr120 \gaph\cellx8640
\pard\intbl\itap1\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\pardeftab720\li120\ri800\sl203\partightenfactor0

\f4\fs18 \cf12     simpleBlock();\cell \lastrow\row
\pard\pardeftab720\ri720\partightenfactor0

\f5\b\fs20 \cf0 Note:
\f1\b0 \'a0If you attempt to invoke a block using an unassigned variable (a\'a0
\f4 \cf12 nil
\f1 \cf0 \'a0block variable), your app will crash.\
\

\f5\b\fs80 \cf16 How Do I Declare A Block in Objective-C?\

\f1\b0\fs60 As a 
\f5\b \cf17 local variable
\f1\b0 \cf16 :\

\f6\fs40 \cf18 returnType\cf16  (^\cf19 blockName\cf16 )(\cf20 parameterTypes\cf16 ) = ^\cf18 returnType\cf16 (\cf20 parameters\cf16 ) \{...\};\

\f1\fs60 As a 
\f5\b \cf17 property
\f1\b0 \cf16 :\

\f6\fs40 @property (nonatomic, copy) \cf18 returnType\cf16  (^\cf19 blockName\cf16 )(\cf20 parameterTypes\cf16 );\

\f1\fs60 As a 
\f5\b \cf17 method parameter
\f1\b0 \cf16 :\

\f6\fs40 - (void)someMethodThatTakesABlock:(\cf18 returnType\cf16  (^)(\cf20 parameterTypes\cf16 ))\cf19 blockName\cf16 ;\

\f1\fs60 As an 
\f5\b \cf17 argument to a method call
\f1\b0 \cf16 :\

\f6\fs40 [someObject someMethodThatTakesABlock:^\cf18 returnType\cf16  (\cf20 parameters\cf16 ) \{...\}];\

\f1\fs60 As a 
\f5\b \cf17 typedef
\f1\b0 \cf16 :\

\f6\fs40 typedef \cf18 returnType\cf16  (^\cf19 TypeName\cf16 )(\cf20 parameterTypes\cf16 );\
\cf19 TypeName\cf16  blockName = ^\cf18 returnType\cf16 (\cf20 parameters\cf16 ) \{...\};\
\

\f7\b\fs42 \cf21 Precompiled header.\

\fs34 What it is?\

\f8\b0\fs26 Prefix.pch
\f7\fs30  is a precompiled header. Precompiled headers were invented 
\b to make compiling faster
\b0 . Rather than parsing the same header files over and over, these files get parsed once, ahead of time.
\f1\fs20 \cf0 \
\pard\pardeftab720\partightenfactor0

\f9\fs24 \cf0 \
\pard\pardeftab720\ri720\partightenfactor0

\b\fs52 \cf22 NSOperation vs. Grand Central Dispatch (GCD)\

\b0\fs32 \cf0 You may have heard of {\field{\*\fldinst{HYPERLINK "http://developer.apple.com/library/ios/%22%20%5Cl%20%22documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html"}}{\fldrslt \cf22 \ul \ulc22 Grand Central Dispatch (GCD)}}. In a nutshell, GCD consists of language features, runtime libraries, and system enhancements to provide systemic and comprehensive improvements to support concurrency on multi-core hardware in iOS and OS X. If you\'92d like to learn more about GCD, you can read our {\field{\*\fldinst{HYPERLINK "http://www.raywenderlich.com/?p=4295"}}{\fldrslt \cf22 \ul \ulc22 Multithreading and Grand Central Dispatch on iOS for Beginners Tutorial}}.\

\fs28 \cf22 NSOperation
\fs32 \cf0  and 
\fs28 \cf22 NSOperationQueue
\fs32 \cf0  are built on top of GCD. As a very general rule, Apple recommends using the highest-level abstraction, and then dropping down to lower levels when measurements show they are needed.\
Here\'92s a quick comparison of the two that will help you decide when and where to use GCD or 
\fs28 \cf22 NSOperation
\fs32 \cf0 :\
\pard\tx220\tx720\pardeftab720\li720\fi-720\ri720\partightenfactor0
\ls1\ilvl0\cf22 \'a5	
\b GCD
\b0 \cf0  is a lightweight way to represent units of work that are going to be executed concurrently. You don\'92t schedule these units of work; the system takes care of scheduling for you. Adding dependency among blocks can be a headache. Canceling or suspending a block creates extra work for you as a developer! :]\
\ls1\ilvl0\cf22 \'a5	
\b NSOperation
\b0 \cf0  adds a little extra overhead compared to GCD, but you can add dependency among various operations and re-use, cancel or suspend them.\
\'a5	\
\pard\tx720\pardeftab720\ri720\partightenfactor0
\cf0 \
\pard\pardeftab720\ri720\partightenfactor0

\fs64 \cf0 Part 1: GCD (Grand Central Dispatch)\

\fs34 \cf23 GCD is the most commonly used API to manage concurrent code and execute operations asynchronously at the Unix level of the system. GCD provides and manages queues of tasks. First, let\'92s see what queues are.\

\fs54 \cf0 What are queues?\

\fs34 \cf23 Queues are data structures that manage objects in the order of First-in, First-out (FIFO). Queues are similar to the lines at the ticket window of the movie theatre. The tickets are sold as first-come, first-serve. The people in the front of the line get to buy their tickets before the others in the line who arrived later. Queues in computer science are similar because the first object added to the queue is the first object to be removed from the queue.\
\

\fs54 \cf0 Dispatch Queues\

\fs34 \cf23 Dispatch queues are an easy way to perform tasks asynchronously and concurrently in your application. They are queues where tasks are being submitted by your app in form of blocks (Blocks of codes). There are two varieties of dispatch queues: (1) serial queues, & (2) concurrent queues. Before talking about the differences, you need to know that tasks assigned to both queues are being executed in separate threads than the thread they were created on. In other words, you create blocks of code and submit it to dispatch queues in the main thread. But all these tasks (Blocks of codes) will run in separate threads instead of the main thread.\

\fs38 \cf24 Serial Queues\

\fs34 \cf23 When you choose to create a queue as serial queue, the queue can only execute one task at a time. All tasks in the same serial queue will respect each other and execute serially. However, they don\'92t care about tasks in separate queues which means that you can still execute tasks concurrently by using multiple serial queues. For example, you can create two serial queues, each queue executes only one task at a time but up to two tasks could still execute concurrently.\
Serial queues are awesome for managing a shared resource. It provides guaranteed serialized access to the shared resource and prevents race conditions. Imagine that there is a single ticket booth but there are a bunch of people who want to buy cinema tickets, here the staff at the booth is a shared resource. It\'92ll be chaotic if the staff has to serve these people all at the same time. To handle this situation, people are required to queue up (serial queue), so that the staff can serve the customers one at a time.\
Again, it doesn\'92t mean the cinema can only handle one customer at a time. If it sets up two more booths, it can serve three customers at one time. This is why I said you can still perform multiple tasks in parallel by using several serial queues.\
The advantages of using serial queues are:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\ri720\partightenfactor0
\ls2\ilvl0\cf23 1	Guaranteed serialized access to a shared resource that avoids race condition.\
2	Tasks are executed in a predictable order. When you submit tasks in a serial dispatch queue, they will be executed in the same order as they are inserted.\
3	You can create any number of serial queues.\
\pard\pardeftab720\ri720\partightenfactor0

\fs38 \cf24 Concurrent Queues\

\fs34 \cf23 As the name suggests, concurrent queues allows you to execute multiple tasks in parallel. The tasks (blocks of codes) starts in the order in which they are added in the queue. But their execution all occur concurrently and they don\'92t have to wait for each other to start. Concurrent queues guarantee that tasks start in same order but you will not know the order of execution, execution time or the number of tasks being executed at a given point.\
For example, you submit three tasks (task #1, #2 and #3) to a concurrent queue. The tasks are executed concurrently and are started in the order in which they were added to the queue. However, the execution time and finish time vary. Even it may take some time for task #2 and task #3 to start, they both can complete before task #1. It\'92s up to the system to decide the execution of the tasks.\

\fs54 \cf0 Using Queues\

\fs34 \cf23 Now that we have explained both serial and concurrent queues, it\'92s time to see how we can use them. By default, the system provides each application with a single serial queue and four concurrent queues. The main dispatch queue is the globally available serial queue that executes tasks on the application\'92s main thread. It is used to update the app UI and perform all tasks related to the update of UIViews. There is only one task to be executed at a time and this is why the UI is blocked when you run a heavy task in the main queue.\
Besides the main queue, the system provides four concurrent queues. We call them Global Dispatch queues. These queues are global to the application and are differentiated only by their priority level. To use one of the global concurrent queues, you have to get a reference of your preferred queue using the function dispatch_get_global_queue which takes in the first parameter one of these values:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\ri720\partightenfactor0
\ls3\ilvl0\cf23 \'a5	DISPATCH_QUEUE_PRIORITY_HIGH\
\'a5	DISPATCH_QUEUE_PRIORITY_DEFAULT\
\'a5	DISPATCH_QUEUE_PRIORITY_LOW\
\'a5	DISPATCH_QUEUE_PRIORITY_BACKGROUND\
\pard\tx220\tx720\pardeftab720\ri720\partightenfactor0
\cf23 These queue types represent the priority of execution. The queue with HIGH has the highest priority and BACKGROUND has the lowest priority. So you can decide the queue you use based on the priority of the task. Please also note that these queues are being used by Apple\'92s APIs so your tasks are not the only tasks in these queues.
\f1\fs26 \cf0 \

\f7\fs44 \cf25 GCD
\f1\fs26 \cf0 \
\pard\pardeftab720\li720\fi-360\ri720\sl390\sa300\partightenfactor0
\ls4\ilvl0
\f8 \cf25 \'a5	GCD
\f10\fs30  is a low-level C-based API that enables very simple use of a task-based concurrency model. 
\f8\fs26 NSOperation
\f10\fs30  and 
\f8\fs26 NSOperationQueue
\f10\fs30  are Objective-C classes that do a similar thing. 
\f8\fs26 NSOperation
\f10\fs30 was introduced first, but as of 10.6 and iOS 4, 
\f8\fs26 NSOperationQueue
\f10\fs30  and friends are internally implemented using 
\f8\fs26 GCD
\f10\fs30 .\
\'a5	In general, you should use the highest level of abstraction that suits your needs. This means that you should usually use 
\f8\fs26 NSOperationQueue
\f10\fs30  instead of 
\f8\fs26 GCD
\f10\fs30 , unless you need to do something that 
\f8\fs26 NSOperationQueue
\f10\fs30  doesn't support.\
\'a5	Note that 
\f8\fs26 NSOperationQueue
\f10\fs30  isn't a "dumbed-down" version of GCD; in fact, there are many things that you can do very simply with 
\f8\fs26 NSOperationQueue
\f10\fs30  that take a lot of work with pure 
\f8\fs26 GCD
\f10\fs30 . (Examples: bandwidth-constrained queues that only run N operations at a time; establishing dependencies between operations. Both very simple with 
\f8\fs26 NSOperation
\f10\fs30 , very difficult with 
\f8\fs26 GCD
\f10\fs30 .) Apple's done the hard work of leveraging GCD to create a very nice object-friendly API with 
\f8\fs26 NSOperation
\f10\fs30 . Take advantage of their work unless you have a reason not to.\
\'a5	\
\pard\pardeftab720\li720\fi-360\ri720\partightenfactor0
\ls4\ilvl0
\f7\fs44 \cf25 \'a5	NSOperationQueue and GCD\
\pard\pardeftab720\li720\fi-360\ri720\sl340\partightenfactor0
\ls4\ilvl0
\fs22 \cf25 \'a5	\
\pard\pardeftab720\li720\fi-360\ri720\sl360\partightenfactor0
\ls4\ilvl0
\f11\b\fs28 \cf25 \'a5	NSOperationQueue and 
\f7 GCD
\b0 \
\ls4\ilvl0
\f8 \'a5	NSOperationQueue
\f7 \'a0predates Grand Central Dispatch and on iOS it doesn't use GCD to execute operations (this is different on Mac OS X). It uses regular background threads which have a little more overhead than GCD dispatch queues.\
\'a5	On the other hand,\'a0
\f8 NSOperationQueue
\f7 \'a0gives you a lot more control over how your operations are executed. You can define dependencies between individual operations for example, which isn't possible with plain GCD queues. It is also possible to cancel operations that have been enqueued in an\'a0
\f8 NSOperationQueue
\f7 \'a0(as far as the operations support it). When you enqueue a block in a GCD dispatch queue, it will definitely be executed at some point.\
\pard\tx220\tx720\pardeftab720\li720\fi-360\ri720\partightenfactor0
\ls4\ilvl0\cf25 \'a5	To sum it up,\'a0
\f8 NSOperationQueue
\f7 \'a0can be more suitable for long-running operations that may need to be cancelled or have complex dependencies. GCD dispatch queues are better for short tasks that should have minimum performance and memory overhead.
\f1\fs26 \cf0 \
\pard\tx220\tx720\pardeftab720\ri720\partightenfactor0
\cf0 \
\pard\pardeftab720\ri720\partightenfactor0

\f7\b\fs32 \cf25 Dispatch queues
\b0  are an easy way to perform tasks asynchronously and concurrently in your application. A task is simply some work that your application needs to perform.\
\
\
\
\pard\pardeftab720\ri720\qc\partightenfactor0

\fs2 \cf26 \

\fs40 \cf27 \

\fs2 \cf26 down vote\
\cf27 accepted\
\pard\pardeftab720\ri720\partightenfactor0

\fs30 \cf28 When you execute something synchronously, you wait for it to finish before moving on to another task. When you execute something asynchronously, you can move on to another task before it finishes.\
\pard\tx220\tx720\pardeftab720\ri720\partightenfactor0
\cf28 That being, said, in the context of computers this translates into executing a process or task on another "thread." A thread is a series of commands--a block of code--that exists as a unit of work. The operating system can manage multiple threads and assign a thread a piece ("slice") of processor time before switching to another thread to give it a turn to do some work. At its core (pardon the pun), a processor can simply execute a command--it has no concept of doing two things at one time. The operating system simulates this by allocating slices of time to different threads.
\f1\fs26 \cf0 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\tx11161\pardirnatural\partightenfactor0

\f9\fs24 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\pard\tx220\tx720\pardeftab720\ri720\partightenfactor0

\f1\fs26 \cf0 \
\
}